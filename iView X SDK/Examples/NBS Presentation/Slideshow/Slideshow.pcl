# -----------------------------------------------------------------------
#
# (c) Copyright 1997-2013, SensoMotoric Instruments GmbH
# 
# Permission  is  hereby granted,  free  of  charge,  to any  person  or
# organization  obtaining  a  copy  of  the  software  and  accompanying
# documentation  covered  by  this  license  (the  "Software")  to  use,
# reproduce,  display, distribute, execute,  and transmit  the Software,
# and  to  prepare derivative  works  of  the  Software, and  to  permit
# third-parties to whom the Software  is furnished to do so, all subject
# to the following:
# 
# The  copyright notices  in  the Software  and  this entire  statement,
# including the above license  grant, this restriction and the following
# disclaimer, must be  included in all copies of  the Software, in whole
# or  in part, and  all derivative  works of  the Software,  unless such
# copies   or   derivative   works   are   solely   in   the   form   of
# machine-executable  object   code  generated  by   a  source  language
# processor.
# 
# THE  SOFTWARE IS  PROVIDED  "AS  IS", WITHOUT  WARRANTY  OF ANY  KIND,
# EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF
# MERCHANTABILITY,   FITNESS  FOR  A   PARTICULAR  PURPOSE,   TITLE  AND
# NON-INFRINGEMENT. IN  NO EVENT SHALL  THE COPYRIGHT HOLDERS  OR ANYONE
# DISTRIBUTING  THE  SOFTWARE  BE   LIABLE  FOR  ANY  DAMAGES  OR  OTHER
# LIABILITY, WHETHER  IN CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT
# OF OR IN CONNECTION WITH THE  SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# -----------------------------------------------------------------------

# Author: 
# (C) 2013 Sensomotoric Instruments 


###################################################################
#																						#
#	choose Calibration method, auto accept, and calibration speed	#
#																						#
###################################################################

# Calibration method 
#double calibration_method = 2.0;
double calibration_method = 5.0;
#double calibration_method = 9.0;
#double calibration_method = 13.0;

# Calibration auto accept
#double calibration_auto_accept = 0.0;
double calibration_auto_accept = 1.0;

# Calibration speed
double calibration_speed = 0.0;
#double calibration_speed = 1.0;


###########################################
#														#
#	choose connection settings to 			#
#	establish communication with iView X	#
#														#
###########################################

# connection settings
string iViewX_IP = "127.0.0.1";
string Local_IP = "127.0.0.1";
int Send_Port = 4444;
int Recv_Port = 5555;


#######################################################
#																		#
#	definition of iView X API functions 					#
#	do not change the instance definitions;				#
#	for more information check the iView X SDK Manual	#
#																		#
#######################################################

#resp definition (accepts mouseclick)
sub bool resp (int button, int current_count)
begin
	if response_manager.total_response_count(button) > current_count then
		return true
	end;
	return false;
end;


# create PCL instance 
iViewXAPI::eye_tracker2 tracker2 = new iViewXAPI::eye_tracker2( "{B7A4A7F7-7879-4C95-A3BA-6CCB355AECF6}" );
int ret = tracker2.connect(iViewX_IP, Send_Port, Local_IP, Recv_Port);
if ret == 1 then

	# create eye_tracker instance 
	eye_tracker tracker = new eye_tracker( "{FDC35980-7480-4761-859F-4DCCFA93BA57}" );
	tracker.start_tracking();



	#############################################################
	#																				#
	#	calibrate, validate eye tracker and start receiving data	#
	#																				#
	#############################################################


	# start calibration 
	tracker.calibrate( et_calibrate_default, calibration_method, calibration_auto_accept, calibration_speed);
	wait_interval (500);

	# start validation 
	tracker.calibrate(2, calibration_method, calibration_auto_accept, calibration_speed);

	# get accuracy measurement 
	double accuracy_x, accuracy_y;
	accuracy_x = tracker2.get_accuracy_x();
	accuracy_y = tracker2.get_accuracy_y();

	# show picture with accuracy text 
	accuracy_text.set_caption("Validation Results: \n\n Accuracy X: " + string(accuracy_x) + "\n Accuracy Y: " + string(accuracy_y));
	accuracy_text.redraw();
	accuracy_picture.present(); 

	wait_interval (1000);
	tracker.set_recording (true);   
	

	####################################################
	#																	#
	# shall images be presented in randomized order?	#
	#																	#
	####################################################

	graphics.shuffle();


	####################################################
	#																	#
	# 	For synchronization of stimulus presentation		#
	#	with eyetracker messages have to be sent to 		#
	#	iView X. Therefore all image names have to		#
	#	be stored in an additional array.					#
	#																	#
	####################################################

	int n_images = graphics.count();

	array<string> filename[n_images];
	loop int i = 1 until i > n_images begin
		filename[i] = graphics[i].filename();
		array<string> filename_split[0];
		filename[i].split ("\\", filename_split);
		filename[i] = (filename_split[filename_split.count()]);
		i = i + 1;
	end;


	#####################################
	#												#
	# main loop for trial presentation	#
	#												#
	#####################################

	int button_count = response_manager.total_response_count (1);

	loop
		int counter = 1
	until false
	begin
		
		# load image in graphics memory
		graphics[counter].load();
		
		# set image as part of stimulus trial
		pic1.set_part( 1, graphics[counter] );
		
		# send command to load stimulus in iView X scene window
		
		tracker.send_command ("ET_BMP " + filename[counter]);
		
		# send synchronization message to iView X
		tracker.send_message (filename[counter]);
		
		# present stimulus
		trial1.present();
		
		# unload image from trial
		graphics[counter].unload();
		
		# wait for response to show next stimulus
		if (response_manager.total_response_count (1) > button_count) then
			button_count = response_manager.total_response_count (1);
			counter = counter + 1;
		end;
		
		# if all images are shown end loop
		if (counter > n_images ) then break; end;
	end;


	##########################################################
	#																			#
	#	stop eyetracker													#
	#																			#
	##########################################################

	tracker.set_recording (false);             
	tracker.stop_tracking();


	##########################################################
	#																			#
	#	save data, use subject prompt for generating filename	#
	#																			#
	##########################################################

	tracker2.save_data(logfile.subject() + ".idf", "description", logfile.subject(), 1);

	# disconnect from eyetracker
	tracker2.disconnect();

else

	# connection could not be established 
	connect_error.present();
	
	loop
	int m_responses = response_manager.total_response_count(1);
	until false
	begin
		# end presentation if button was pressed 
		if resp(1, m_responses) then
			break;
		end;
	end;
	
end;

